%; whizzy -pdf

\documentclass[a4paper,11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[spanish]{varioref}

\title{Guión de prácticas:\\Gestión de ramas\footnote{Sin preguntas por el momento.}}
\author{Antonio García Domínguez}
\date{\today}

\input{../preambulo-guiones}

\begin{document}

\maketitle
\begin{center}
  Distribuido bajo la licencia CC v3.0 BY-SA (\url{http://creativecommons.org/licenses/by-sa/3.0/deed.es}).

  \vskip 2em

  \includegraphics{../cc-by-sa}
\end{center}

\vskip .1\textheight

\tableofcontents{}

\clearpage

\section{Gestión básica de ramas}
\label{sec:creacion-ramas}

Las revisiones enviadas a un repositorio Git forman un grafo acíclico
dirigido, en el que podemos tener líneas de revisiones que se dividen
a partir de un cierto punto en múltiples ramas. Estas ramas
posteriormente pueden reunirse opcionalmente, aunque no es
estrictamente necesario.

Siempre estamos trabajando con una rama: por defecto, Git crea siempre
la rama \rama{master}, considerada normalmente como la rama principal
de desarrollo (\rama{trunk} para aquellos que conozcan
Subversion). Podemos ver en qué rama estamos con:

\begin{lstlisting}
git branch
\end{lstlisting}

Obtendremos una salida como:

\begin{lstlisting}
* master
\end{lstlisting}

Esta salida indica que nos hallamos actualmente trabajando sobre la
punta de la rama \rama{master}, con lo que cualquier revisión que
vayamos enviando no sólo creará el objeto correspondiente, sino que
además hará avanzar el puntero \rama{master} además del
\commitish{HEAD}. Puede que no estemos sobre la punta de ninguna rama
si hemos movido el \commitish{HEAD} manualmente (después veremos
cómo). En dicho caso veríamos algo así:

\begin{lstlisting}
* (no branch)
  master
\end{lstlisting}

Hay que tener cuidado: si creamos nuevas revisiones sin que sean
alcanzables por una rama, estas revisiones no son alcanzables de forma
normal y serán recolectadas como basura tras un período de gracia de
30 días por defecto. Podemos marcar la revisión actual como la punta
de una rama (sin llegar a cambiarnos a ella) con:

\begin{lstlisting}
git branch -a nombrerama
\end{lstlisting}

Por otro lado, podemos eliminar una rama (es decir, la referencia a su
punta) con:

\begin{lstlisting}
git branch -d nombrerama
\end{lstlisting}

Sin embargo, hay que tener cuidado en ciertos casos. Borrar la
referencia a una rama que ya ha sido reunida con alguna otra no tiene
problema, ya que sus revisiones son alcanzables desde la otra rama,
como se ve en el caso de \rama{develop}
en~\vref{fig:sin-problema-borrar-rama}. Sin embargo, si aún no se ha
hecho esto, como en~\ref{fig:problema-borrar-rama}, podríamos acabar
perdiendo las revisiones de dicha rama, al quedar inalcanzables por
toda referencia.

Por ello, \orden{git checkout -d develop} fallaría en el segundo caso,
y si de verdad quisiéramos eliminar esa rama y descartar todas sus
revisiones, sustituiríamos la opción \orden{-d} por \orden{-D}. Esto
es útil, por ejemplo, para descartar una rama que hayamos visto
improductiva por completo sin tener que reunirla.

\begin{figure}
  \centering
  \resizebox{\textwidth}{!}{\input{sinproblema-borrar-ramas}}
  \caption{Situación no problemática al borrar la rama \rama{develop}}
  \label{fig:sin-problema-borrar-rama}
\end{figure}

\begin{figure}
  \centering
  \resizebox{\textwidth}{!}{\input{problema-borrar-ramas}}
  \caption{Situación problemática al borrar la rama \rama{develop}}
  \label{fig:problema-borrar-rama}
\end{figure}

Se recuerda que para ver de forma cómoda el grafo de revisiones
desde la revisión actual, podemos usar \orden{gitk}, y para ver el
grafo completo, se puede utilizar \orden{gitk --all}.

\section{Cambio entre ramas}
\label{sec:cambio-entre-ramas}

Para cambiar entre ramas, o en general mover el \rama{HEAD} de forma
no destructiva a cualquier revisión, usaremos la orden \orden{git
  commit <treeish>}. Así, cambiar a la rama \rama{develop} es tan
simple como ejecutar \orden{git checkout develop}. Esto actualizará
tanto el índice como el directorio del trabajo al aspecto que tenían
en dicha revisión. Si tenemos cambios locales sobre ficheros cuyo
contenido es distinto en la revisión en la que estamos trabajando,
\orden{git checkout} informará del error y abortará su ejecución.

Para solventar este problema, tenemos dos opciones:

\begin{enumerate}
\item Guardar los cambios aparte mediante \orden{git stash}, una nueva
  orden introducida en Git v1.5.3, antes de cambiar de revisión. Esta
  orden es puramente de conveniencia: internamente usa operaciones
  normales y corrientes de Git.

  Las entradas del \emph{stash} forman una pila, y se pueden gestionar
  de forma muy flexible. Las órdenes disponibles son:

  \begin{itemize}
  \item \orden{git stash}: guarda los cambios sobre el índice y el
    directorio de trabajo aparte en una nueva entrada, y deja el
    índice y el directorio de trabajo con los contenidos de
    \commitish{HEAD}.
  \item \orden{git stash apply [stash@\{N\}]}: toma la entrada $N$ y
    aplica sus cambios. Por defecto, utiliza $N=0$, es decir, el tope
    de la pila.
  \item \orden{git stash drop stash@\{N\}}: elimina la entrada $N$.
  \item \orden{git stash pop}: aplica el tope de la pila y lo retira.
  \item \orden{git stash clear}: elimina todas las entradas.
  \item \orden{git stash list}: lista todas las entradas.
  \end{itemize}

\item Obligar con la opción \orden{-m} de \orden{git checkout} a hacer
  una reunión (veremos posteriormente en qué consisten) entre el
  estado del índice, la revisión en que se estaba y la revisión
  destino. Esto puede generar conflictos: los veremos posteriormente.
  
\end{enumerate}

Se recuerda que al cambiar a una revisión que no esté en la punta de
una rama (Git nos avisará con algo del estilo de <<moving to X which
isn't a local branch>>), las posteriores revisiones que enviemos no
serán alcanzables desde ninguna de las ramas. Deberíamos de añadir una
rama en donde estemos para evitar esto, y cambiar a dicha
rama. Podríamos hacerlo así para la revisión con \emph{commitish}
\commitish{HEAD~2}

\begin{lstlisting}
git checkout HEAD~2
git branch -a otrarama
git checkout otrarama
\end{lstlisting}

Existe un atajo:

\begin{lstlisting}
git checkout -b otrarama HEAD~2
\end{lstlisting}

\section{Reunión de ramas}
\label{sec:reunion-ramas}

% git merge
% concepto de fast forward
%
% conflictos:
% * git diff --ours
% * git diff --theirs
% * git diff --base
% * resolución
%
% git revert -m

\section{Reescribir varias revisiones en base a otra}
\label{sec:cambiar-rev-base-rama}

% git rebase
% git rebase --interactive

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
