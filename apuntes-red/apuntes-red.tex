%; whizzy -pdf

\documentclass[a4paper,11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[spanish]{varioref}
\usepackage{hyperref}
\usepackage{subfig}

\title{Apuntes de prácticas:\\Colaboración con Git}
\author{Antonio García Domínguez\\nyoescape arroba gmail punto com}
\date{\today}

\input{../preambulo-guiones}

\begin{document}

\maketitle
\begin{center}
  Distribuido bajo la licencia CC v3.0 BY-SA (\url{http://creativecommons.org/licenses/by-sa/3.0/deed.es}).

  \vskip 2em

  \includegraphics{../cc-by-sa}
\end{center}

\vskip .1\textheight

\tableofcontents{}
\listoffigures{}
\clearpage

\section{Acciones básicas}
\label{sec:metodos-de-acceso}

\subsection{Clonado de repositorios}
\label{sec:conceptos-basicos}

Cuando varias personas han de colaborar en un mismo proyecto en el que
se use Git, normalmente usarán un clon de algún repositorio destacado
como punto inicial, creado mediante una orden del estilo de \orden{git
  clone url}, donde la URL variará según qué protocolo usemos. Una vez
se cree el clon, podemos indicar a Git la URL desde que clonamos
utilizando el identificador \remote{origin}. Éste es un ejemplo de un
<<remote>> de Git: una referencia por nombre a una URL con ciertos
atributos adicionales configurables. Podemos añadir los nuestros
propios mediante las órdenes \orden{git remote add nombre url} y
retirarlos con \orden{git remote rm nombre}.

Nuestro clon del repositorio destacado incluirá, además de los objetos
que en ese momento tenía el repositorio, referencias de sólo lectura a
las revisiones en que se hallaban las ramas disponibles. Estas últimas
son conocidas como \emph{ramas remotas}, y para desarrollar a partir
de ellas necesitaremos usar nuestras propias ramas locales: podemos
comenzar nuevas ramas desde los puntos señalados por las ramas
remotas, o reunir nuestras ramas locales con ellas.

% figura: original
% figura: clonado

\subsection{Recepción de revisiones}
\label{sec:recib-los-camb}

Periódicamente, podremos tomar los nuevos objetos que se hayan creado
en cualquiera de los repositorios remotos que estemos monitorizando y
añadirlos a nuestro repositorio, actualizando las ramas remotas. Para
ello, usaremos la orden \orden{git fetch [repositorio
  [refspec]]}. Según vayamos dando más o menos argumentos, su lógica
cambiará:

\begin{itemize}
\item Sin argumentos, es equivalente a \orden{git fetch origin}.

\item Si se especifica sólo el repositorio, mediante su URL o el
  nombre de su \emph{remote}, buscará su valor en varios sitios. Uno
  de ellos es la variable \variable{remote.mirama.fetch} de
  \fichero{.git/config}, donde \variable{mirama} es el nombre de la
  rama actual.

  Git aprovecha este comportamiento cuando clonamos un repositorio: al
  dar el valor correcto a la variable \variable{remote.origin.fetch},
  podemos hacer \orden{git fetch} sin tener que pasar ningún
  argumento.

\item Con los dos argumentos su comportamiento ya queda completamente
  definido. El segundo argumento es un tanto especial: la sintaxis es
  algo más compleja, teniendo la forma \verb#[+]fuente[:destino]#. Su
  significado también se va construyendo poco a poco:

  \begin{itemize}
  \item Con \verb#fuente# a secas, decimos que queremos recibir la
    rama remota \rama{fuente} y situar la punta en la referencia
    \rama{FETCH\_HEAD}. Esto es útil sobre todo para ver qué cambios
    se han introducido en una rama remota sin que afecte a nuestro
    repositorio.

  \item \verb#fuente:destino# toma la referencia fuente y actualiza o
    crea con ella la referencia
    destino. \verb|refs/heads/*:refs/remotes/origin/*|, por ejemplo,
    es el valor configurado en \variable{remote.origin.fetch} al
    clonar un repositorio. Este valor es el que indica a \orden{git
      fetch} que actualice todas las ramas remotas con sus valores en
    el repositorio remoto, manteniendo los nombres.

  \item \verb#+fuente:destino#, por otro lado, permite que aunque la
    punta de la fuente no sea descendiente de la punta actual del
    destino (es decir, no se pueda simplemente hacer un \emph{fast
      forward}), se permita la actualización. Esta opción conlleva
    ciertos riesgos: puede verse en la figura~\ref{fig:pull-ff} cómo
    forzar la actualización ha hecho que \commitish{C} quede sin
    referenciar por ninguna rama.

  \end{itemize}
\end{itemize}

\begin{figure}
  \centering
  \subfloat[Local]{\resizebox{.75\textwidth}{!}{\input{fetch-ff-1}}}

  \subfloat[Remoto]{\resizebox{.75\textwidth}{!}{\input{fetch-ff-2}}}

  \subfloat[Local tras \orden{git fetch origin +master:master}: se pierde \commitish{C}]{\resizebox{.75\textwidth}{!}{\input{fetch-ff-3}}}
  \caption{Problema introducido por actualizaciones no \emph{fast forward}}
  \label{fig:pull-ff}
\end{figure}

\subsection{Reunión de las ramas locales con las remotas}
\label{sec:reunion-loc-rem}

\orden{git fetch} no reúne nuestras ramas locales con las ramas
remotas (véase la figura~\vref{fig:fetch-nomerge}): para ello
tendremos que usar \orden{git merge}, tal y como se vio en los apuntes
de ramas. Podemos unir \orden{git fetch} y \orden{git merge} en una
sola orden, \orden{git pull [repositorio refspecs]}.

\begin{nota}
  he estado intentando utilizar \orden{git pull} especificando
  únicamente el repositorio y dejando las ramas en la configuración
  con la variable \variable{branch.rama.merge}, pero parece depender
  del valor de la variable \variable{branch.rama.remote}, y si ésta
  también se especifica ya no tiene sentido usar la versión de un solo
  argumento \orden{git pull repositorio}. Si alguien tiene éxito en
  hacer esto que me envíe un correo, gracias.
\end{nota}

\begin{figure}
  \centering
  \subfloat[Local]{\resizebox{.75\textwidth}{!}{\input{fetch-nomerge-1}}}

  \subfloat[Remoto]{\resizebox{.75\textwidth}{!}{\input{fetch-nomerge-2}}}

  \subfloat[Local tras \orden{git fetch}: \rama{master} no se mueve]{\resizebox{.75\textwidth}{!}{\input{fetch-nomerge-3}}}

  \caption{Ejemplo de cómo \orden{git fetch} no reúne ramas}
  \label{fig:fetch-nomerge}
\end{figure}

En su forma completa con la referencia al repositorio y al menos el
nombre de una rama de dicho repositorio, el proceso seguido por
\orden{git pull X Y...} es:

\begin{enumerate}
\item Primero se ejecuta \orden{git fetch} con todos los argumentos
  recibidos para recibir los objetos del repositorio remoto.

\item Por último se reúne la rama actual con las puntas de todas las
  ramas referenciadas en los argumentos \orden{Y...}, usando
  \orden{git merge}. Si se pasa la opción \orden{--rebase} se
  sustituye por \orden{git rebase}. No olvidar que sólo puede usarse
  esta última orden si aún nadie tiene la parte del historial que va a
  ser afectada.
\end{enumerate}

Cuando no decimos nada, \orden{git pull} utiliza algunos ficheros de
configuración, con ciertos cambios. Simplificando un poco, sería algo
así:

\begin{enumerate}
\item La referencia al repositorio en cuestión se obtiene a partir de
  la variable local \variable{branch.mirama.remote} de
  \fichero{.git/config}, suponiendo que nos hallamos en la rama
  \rama{mirama}.

\item Los argumentos para \orden{git fetch} se extraen de la variable
  local \variable{remote.miremoto.fetch}, suponiendo que el remoto
  antes indicado era \remote{miremoto}.

\item Las ramas del repositorio remoto con que se debería reunir la
  rama actual se encuentran en la variable local
  \variable{branch.mirama.merge}.
\end{enumerate}

Estas tres variables son configuradas automáticamente para la rama
principal y el \emph{remote} \remote{origin} creados tras un clonado.
Si creamos una nueva rama local, tendremos que indicarle de qué
\emph{remote} y rama remota actualizarse. Suponiendo que queramos
desarrollar a partir de la rama \rama{mirama} del \emph{remote}
\remote{miremoto} en una nueva rama \rama{nuevarama}, tenemos varias
opciones:

\begin{enumerate}
\item Ir indicándolo manualmente con más argumentos:

\begin{lstlisting}
git pull miremoto mirama:nuevarama
\end{lstlisting}

\item Crear la rama con la opción \orden{--track}. Hay varias formas
  de hacerlo. La más sencilla es:

\begin{lstlisting}
git checkout -b nuevarama --track miremoto/mirama
\end{lstlisting}

Se trata de un atajo para:

\begin{lstlisting}
git branch --track nuevarama miremoto/mirama
git checkout nuevarama
\end{lstlisting}

\item Configurarlo manualmente. Hay varios posibles ficheros a
  modificar, pero si usáramos \fichero{.git/config}, por ejemplo,
  ejecutaríamos algo así:

\begin{lstlisting}
git checkout -b nuevarama miremoto/mirama
git config branch.nuevarama.remote miremoto
git config branch.nuevarama.merge mirama
\end{lstlisting}
\end{enumerate}

\subsection{Envío de revisiones}
\label{sec:envio-de-cambios}

Otras veces desearemos enviar nuestras propias revisiones a otro
repositorio. Esta acción se realiza mediante la orden \orden{git push
  [repositorio [refspecs]]}, y al igual que \orden{git fetch}, su
significado se va construyendo progresivamente a medida que se le
pasan argumentos:

\begin{itemize}
\item \orden{git push} sin argumentos equivale a \orden{git push origin}.

\item Si se ejecuta \orden{git push nombre}, y existe una variable
  \variable{remote.nombre.push} con una o más \emph{refspecs} \orden{Y...},
  entonces la orden equivale a \orden{git push nombre Y...}.

\item Si se ejecuta \orden{git push nombre} pero no existe la anterior
  variable, entonces equivale a \orden{git push nombre :}.

\item Una vez todos los argumentos quedan determinados, \orden{git
    push X Y...} actualizaría cada una de las ramas destino con los
  objetos del repositorio local, recorriendo cada uno de los
  \emph{refspec} proporcionados.

  Estos \emph{refspec} son un tanto especiales, y difieren en
  bastantes cosas de los de \orden{git fetch} (y por tanto de los de
  \orden{git pull}). La sintaxis básica \verb#[+]fuente[:destino]#
  sigue siendo admitida y funciona de la misma forma, pero hay algunas
  diferencias:

  \begin{itemize}
  \item Si no damos el nombre del destino, se asume que es el mismo
    que el origen. Estas dos órdenes son equivalentes:

\begin{lstlisting}
git push origin foo
git push origin foo:foo
\end{lstlisting}

  \item La fuente puede ser cualquier \emph{commitish}, y en
    particular podemos enviar etiquetas:

\begin{lstlisting}
git tag -a v1.0
git push origin v1.0
\end{lstlisting}

    Si usamos un \emph{commitish} a una revisión cualquiera, estaremos
    obligados a dar un destino:

\begin{lstlisting}
git push origin master~5:otrarama
\end{lstlisting}

  \item Podemos omitir la fuente y dejar sólo el destino, borrando así
    la rama (\verb#:mirama#)o etiqueta (\verb#:v1.0#) indicada en el
    destino.

  \item Podemos omitir tanto la fuente como el destino, quedando
    \verb#:#, o \verb#+:# para actualizar incluso cuando no sea un
    \emph{fast forward}. El comportamiento de \orden{git push} al
    recibir este argumento es un tanto peculiar: básicamente, cada
    rama en el repositorio indicado es actualizada desde la rama local
    con el mismo nombre, si existe.
  \end{itemize}

\end{itemize}

\subsection{Autoría de las líneas de un fichero}
\label{sec:autoria-de-lineas}

Para ver quién es el responsable de cada línea de un fichero, es
decir, la última persona que la modificó, y cuándo se hizo, Git nos
proporciona la orden \orden{git blame}, a la que en su forma más
sencilla únicamente tenemos que pasar la ruta de un fichero:

\begin{lstlisting}
git blame fichero
\end{lstlisting}

Si queremos activar todas las heurísticas de líneas movidas
(\orden{-M}) y copiadas (\orden{-C}) desde otros ficheros al máximo
(otra vez \orden{-C}), mostrando los números de línea originales
(\orden{-n}), usaremos:

\begin{lstlisting}
git blame -n -M -C -C fichero
\end{lstlisting}

Evidentemente, esta segunda versión puede que tarde más, pero nos dará
mucha más información.

\section{Conectividad por red entre repositorios}
\label{sec:conectividad-por-red}

\subsection{Introducción}
\label{sec:introduccion}

Git puede trabajar completamente en local, utilizando rutas a otros
directorios y URL de la forma \url{file:///ruta/a/.git}, pero esto
evidentemente no es suficiente: normalmente, los repositorios con los
que querremos colaborar se hallarán en otras máquinas, y para ello
tendremos que utilizar alguna conexión de red.

Git dispone de múltiples opciones según nuestras necesidades, e
incluso facilita su uso entre entornos donde la conectividad es
intermitente o inexistente o no tenemos los permisos de escritura
necesarios. En esta sección daremos un repaso por las distintas
opciones, con sus ventajas y desventajas.

Antes que nada, es importante destacar que cualquier repositorio que
sea accesible por terceras partes debería ser lo que se conoce en Git
como un repositorio <<pelado>> (\emph{bare} en el original
inglés). Estos repositorios tienen la particularidad de que no
disponen de un directorio de trabajo ni un índice, y así evitan que
cualquiera trabaje en ellos y se confunda cuando cambien sus objetos
tras un \orden{git push} remoto y no se actualice su directorio de
trabajo. Sólo sirven como punto de reunión para varios
desarrolladores. Lo normal es que, en caso de que necesitemos un
repositorio público, nuestro repositorio privado sea un clon de éste,
para facilitarnos posteriormente el intercambio de revisiones.

\subsection{Acceso por SSH}
\label{sec:acceso-ssh}

El acceso por el protocolo cifrado y autenticado Secure Shell (SSH) es
el preferido, de lejos, para realizar cualquier tipo de operación con
Git que requiera autenticación: es el utilizado normalmente para
realizar la operación \orden{git push} y también puede usarse para
limitar el acceso de lectura. Las URL de acceso a un repositorio por
SSH tienen la forma \url{usuario@host:ruta}, del mismo estilo que se
usan en herramientas como \orden{scp}, por ejemplo.

En su forma más básica, este método de acceso requiere que cada
usuario tenga una cuenta en una máquina dedicada. De todas formas, Git
incluye un shell de entrada limitado exclusivamente a las órdenes
\orden{git push} y \orden{git fetch} (y por ende \orden{git pull})
llamado \orden{git-shell}, con lo que se reduce a un problema sobre
todo administrativo, y no tanto de seguridad. Podemos incluso reunir
todos los directorios personales en uno solo y controlar el acceso a
cada repositorio mediante el sistema de permisos clásico de UNIX.

Hay otra posibilidad que puede resultar más cómoda y a la vez más
segura de utilizar: Gitosis. Se trata de un conjunto de guiones Python
que permiten gestionar una serie de repositorios Git a través de un
repositorio Git. El proceso general, tomado de~\cite{HostingGit}, es
el que sigue:

\begin{enumerate}
\item Necesitaremos algunos paquetes Debian:

\begin{lstlisting}
sudo aptitude install python-setuptools
\end{lstlisting}

\item Descargamos Gitosis clonando su repositorio, y lo instalamos:

\begin{lstlisting}
git clone git://eagain.net/gitosis.git
cd gitosis
sudo python setup.py install
\end{lstlisting}

\item Se crea una única cuenta de usuario llamada \usuario{git}, que
  no tendrá contraseña. Esta cuenta se trata de un usuario de sistema
  con su propio directorio personal y un shell Bourne básico
  (\fichero{/bin/sh}).

\item Crearemos un par de claves pública y privada SSH ejecutando:

\begin{lstlisting}
ssh-keygen -t rsa
\end{lstlisting}

\item Copiaremos la clave pública que se habrá creado en su
  localización a \fichero{/tmp}, y ejecutaremos:

\begin{lstlisting}
sudo -H -u git gitosis-init < /tmp/id_rsa.pub
\end{lstlisting}

  Entre otras cosas, esta acción prepara el directorio personal del
  usuario de Git para que sólo sea accesible para el usuario con la
  clave pública SSH proporcionada, y únicamente para hacer \orden{git
    push}, \orden{git pull} \orden{git fetch}. Para ello configura
  debidamente el fichero \fichero{\~{}/.ssh/authorized\_keys}

\item Ya podemos clonar el repositorio de administración de Gitosis:

\begin{lstlisting}
git clone git@127.0.0.1:gitosis-admin.git
\end{lstlisting}

  Si la clave privada SSH se halla cifrada, se nos pedirá la
  clave. Así, un atacante tendría no sólo que tener una copia de la
  clave privada, sino también su propia clave de cifrado. Además,
  normalmente las claves privadas SSH no viajan por la red (tenemos
  una por usuario y máquina).

\item El contenido del repositorio es muy sencillo: hay un directorio
  \fichero{keydir} en el que situaremos todas las claves públicas SSH
  de los usuarios que queramos reconocer (con extensión
  \fichero{.pub}), y un fichero \fichero{gitosis.conf} que
  modificaremos para definir nuevos grupos de usuarios y cambiar las
  opciones por defecto y/o específicas a ciertos repositorios. Sólo
  tendremos que ir creando nuevas revisiones de la configuración y
  empujarlas al servidor.

  Podemos seguir las instrucciones de la web anterior, o las del
  fichero \fichero{example.conf} que incluye Gitosis. En particular,
  el segundo fichero menciona la posibilidad de dejar que Gitosis sea
  quien controle el acceso mediante Web o con el demonio de lectura
  anónima a ciertos repositorios.

\end{enumerate}

\begin{nota}
  he tenido algunos problemas para que Git use la clave generada por
  \orden{ssh-keygen} a la hora de acceder a los repositorios
  gestionados con Gitosis. Si alguien sabe algo del tema, que me envíe
  un correo, por favor.
\end{nota}

\subsection{Acceso por el protocolo Git}
\label{sec:acceso-git}

El acceso por SSH es bastante eficiente en términos de ancho de banda,
pero evidentemente el cifrado, la autenticación y demás imponen una
carga administrativa y de rendimiento. Cuando no necesitemos el
cifrado ni la autenticación, como en el caso del acceso de sólo
lectura en los proyectos de software libre y/o código abierto, podemos
usar el protocolo de transferencia propio de Git, que es
extremadamente eficiente y permite clonar de manera rápida los
repositorios. Las URL tienen la forma \url{git://host/ruta}.

Para usarlo para compartir nuestros repositorios, únicamente tenemos
que iniciar el demonio, que quedará normalmente a la escucha en el
puerto 9418 TCP, con una lista de rutas a los directorios
\fichero{.git} o, preferiblemente, a los repositorios <<pelados>>:

\begin{lstlisting}
git daemon /ruta/a/pelado.git /ruta/a/nopelado/.git
\end{lstlisting}

Por razones de seguridad, el demonio se negará en redondo a servir
cualquier otra cosa que no sea un repositorio Git, e incluso así, sólo
lo hará si contiene un fichero (da igual que esté vacío) llamado
\fichero{git-daemon-export-ok}. Esta última comprobación puede
desactivarse con \orden{--export-all} si se desea. Si utilizamos
Gitosis, con poner la variable \variable{daemon} al valor <<yes>> y
empujar la revisión correspondiente se nos creará sin más problemas.

Otra configuración muy común es situar todos los repositorios como
subdirectorios de un directorio principal (como en el caso de
Gitosis). Para este escenario, el demonio dispone de la orden
\orden{--base-path}. Si estuviéramos usando el esquema propuesto por
Gitosis, podríamos hacer algo así:

\begin{lstlisting}
sudo -H -u git git daemon --base-path=/home/git/repositories/
\end{lstlisting}

El protocolo de Git permite hacer envíos anónimos con \orden{git
  push}, pero no por defecto: tendremos que invocar al demonio y
activar dicho servicio explícitamente con
\orden{--enable=receive-pack}. Sólo se recomienda su uso en entornos
muy amigables, como una LAN muy controlada.

\subsection{Acceso por HTTP}
\label{sec:acceso-http}

Si nuestra mayor preocupación es el mantenimiento de conectividad
incluso ante cortafuegos muy restrictivos, muy comunes en las grandes
organizaciones, nuestra mejor opción es HTTP, el único protocolo
permitido por la mayoría. No es el mejor en rendimiento, y requiere
algo de cuidado en su uso, sin embargo, por lo que en caso de ser
posible, se recomienda el uso de las dos opciones anteriores. Podemos
conseguir cifrado y autenticación segura mediante SSL (incluso HTTP
Digest no es del todo seguro~\cite{HTTPDigest}). Las URL son de la
forma \url{http://host/ruta} o \url{https://host/ruta}.

\begin{nota}
  actualmente (desde el commit \commitish{v1.6.0-rc1-92-g0d79a45}) se
  está trabajando en un reemplazo que efectivamente consistiría en una
  traducción a HTTP del protocolo Git, permitiendo así un acceso
  eficiente, transparente para cortafuegos y autenticado. De todas
  formas, a fecha de hoy (11 de agosto del 2008) sólo permite el
  acceso para lectura, emulando al servidor <<tonto>> tradicional.
\end{nota}

Para preparar un repositorio Git para su acceso de sólo lectura por
HTTP, hay que seguir una serie de recomendaciones:

\begin{enumerate}
\item Debería de ser un repositorio <<pelado>>, como de costumbre.
\item Hay que ejecutar manualmente una vez al menos por repositorio la
  orden \orden{git-update-server-info}, que dejará información
  necesaria para que el cliente pueda seguir funcionando incluso con
  un servidor que sólo sabe servir ficheros estáticos.
\item Por si alguien realiza algún \orden{git push} posteriormente por
  SSH, se tendrá que dar permisos de ejecución al gancho
  \fichero{hooks/post-update} del repositorio, para que se ejecute
  \orden{git-update-server-info} en cada actualización de nuevo.
\item Habrá que configurar en el fichero global para Git para el
  usuario o usuarios que alojen los repositorios Git que no se
  empaqueten las referencias de los repositorios (suponemos que sólo
  servimos <<pelados>> aquí), cosa que haría dejar de funcionar a los
  clientes por HTTP:
\begin{lstlisting}
git config --global gc.packrefs notbare
\end{lstlisting}
\end{enumerate}

Hecho esto, servirlo para sólo lectura es tan sencillo como ofrecer
sus ficheros de manera estática por cualquier servidor HTTP que
queramos. Si además queremos poder hacer \orden{git push}, habrá que
seguir algunas recomendaciones adicionales (complementadas y ampliadas
en~\cite{GitHTTPS}):

\begin{enumerate}
\item Habrá que activar su acceso por WebDAV, habilitando el sistema
  de cerrojos necesario y restringiendo su acceso a los usuarios
  autenticados. Se incluye en el repositorio de estos apuntes un
  fichero \fichero{conf-apache/gitweb} de configuración de Apache de
  ejemplo. Este fichero también detalla una forma en que se podría
  utilizar el CGI de Gitweb para servir una interfaz de sólo lectura
  al contenido de una serie de repositorios.

\item Además, se tendrá que asegurar que todos los clientes utilicen
  versiones relativamente recientes de Git (1.5.4+ como mínimo, aunque
  se recomienda 1.5.6+) y de la biblioteca Curl (supuestamente 7.6+
  vale, pero nos hemos encontrado con problemas, así que recomendamos
  7.8+). Esto se debe a que, como no hay servidor que se ocupe de
  actualizar los ficheros del repositorio por su cuenta, son los
  propios clientes (con los defectos que traigan sus versiones) los
  que lo actualizan todo, sustituyendo entre otras cosas a las
  ejecuciones posteriores a la primera del guión
  \orden{git-update-server-info}.
\end{enumerate}

\subsection{Acceso por Web}
\label{sec:acceso-por-web}

Aunque técnicamente sigue siendo HTTP, consideramos que el acceso
mediante páginas Web constituye su propio apartado. Para un solo
directorio, podemos utilizar \orden{git instaweb}, para ver cómo
quedaría Gitweb sobre él. Suponiendo que utilizamos Apache, nos
situaríamos en nuestro repositorio de trabajo y ejecutaríamos algo
así:

\begin{lstlisting}
git instaweb --httpd=apache
\end{lstlisting}

Para más de un directorio, se recomienda tener un servidor Web
debidamente configurado, que utilice el CGI de Gitweb tras haberlo
configurado debidamente. Si usamos Gitosis y sus variables
\variable{gitweb}, no debemos de olvidar referenciar en
\fichero{gitweb.cgi} a la lista de proyectos incluida en
\fichero{\~{}git/gitosis/projects.list}, o dichas variables no tendrán
efecto alguno.

Otra opción es usar algún software de gestión de proyectos y la
integración de Git que incluya. Existe un plug-in, aunque algo
inmaduro, de Git para el conocido Trac~\cite{GitPluginTrac,Trac}, pero
recomiendo en su lugar utilizar Redmine~\cite{Redmine}, que además de
tener soporte para una mayor variedad de sistemas de control de
versiones, permite utilizar la misma base de datos para gestionar
múltiples proyectos. 

La única pega es que la configuración inicial es algo más compleja,
recomendándose el uso de Apache como proxy inverso del servidor Apache
Mongrels que alojará a Redmine, ya que es una aplicación Ruby. El
proceso de instalación se halla bien documentado en su página oficial,
y de todas formas se ha incluido también en
\fichero{conf-apache/redmine-git} un fichero de configuración de
Apache que representa un caso más realista.

\subsection{Acceso en conectividad limitada}
\label{sec:acceso-otros}

Puede que no dispongamos de una conexión de red decente al repositorio
al que o desde el cual queramos enviar nuestros cambios: la red no
funciona, tenemos poco ancho de banda, el cortafuegos es más estricto
de la cuenta o estamos de viaje, por ejemplo. Otras veces, puede que
sencillamente no tengamos los permisos necesarios de escritura, pero
aún así queramos hacer lo más fácil posible a los desarrolladores
originales el uso de nuestras aportaciones.

Para estos casos, Git dispone de ciertas facilidades:

\begin{itemize}
\item \orden{git bundle} permite empaquetar en un único fichero una
  serie de revisiones de una rama, llevarlo en el medio que haga falta
  a otro sitio (como un \emph{pendrive} USB o un CD, por ejemplo), y
  volver a crear esas revisiones en el otro lado. Los pasos serían:

  \begin{enumerate}
  \item Creamos el fichero con:

\begin{lstlisting}
git bundle create mibundle a..b
\end{lstlisting}

    Es importante que \commitish{a} sea el \emph{commitish} de una
    revisión que sepamos que existe en el otro lado, y que
    \commitish{b} sea alguna rama que exista también en el otro lado,
    o de lo contrario no podremos realmente actualizar nada.

  \item Lo llevamos como sea a donde sea y lo usamos como sustituto
    del repositorio de un \orden{git fetch} o \orden{git pull}:

\begin{lstlisting}
git pull ../mibundle master
git fetch ../mibundle master:origin/master
\end{lstlisting}

    La primera orden es un \orden{git pull} normal y corriente, y la
    segunda orden actualiza una rama remota a partir de un
    \emph{bundle}.
  \end{enumerate}

\item Si lo que nos falta es acceso de escritura a un repositorio, la
  forma más directa es crear un fichero \fichero{diff} y que otra
  persona lo aplique. No hace falta que usemos Git para la primera
  parte, pero \orden{git diff a..b} puede ser muy útil, como aquí:

\begin{lstlisting}
git diff HEAD^..HEAD | gzip -9 > miparche.diff.gz
\end{lstlisting}

  Ahora se envía el fichero \fichero{miparche.diff.gz} a quien sea,
  que ejecutaría esto sobre su repositorio:

\begin{lstlisting}
zcat miparche.diff.gz | git apply -
\end{lstlisting}

\item Otra forma más directa de hacerlo sería dar formato a cada
  parche como un correo especial que pudiera recibirse y aplicarse
  directamente. Esto se puede hacer con las órdenes \orden{git
    format-patch}, \orden{git send-email} y \orden{git am}, que hacen
  lo siguiente:

  \begin{enumerate}
  \item \orden{git format-patch} convierte una serie de revisiones a
    un formato que es legible por humanos y contiene toda la
    información necesaria para Git. Normalmente se vuelcan como
    ficheros de un directorio de correos:

\begin{lstlisting}
git format-patch -o parches master~2..
\end{lstlisting}

  \item Ahora se envían por correo:

\begin{lstlisting}
git send-email ../parches
\end{lstlisting}

  \item Si recibimos los correos en formato \emph{mbox}, usando
    \orden{mutt}, por ejemplo, podemos aplicar sus cambios con:

\begin{lstlisting}
git am ~/mbox
\end{lstlisting}

  \end{enumerate}
\end{itemize}

\section{Flujos de trabajo usuales con Git}
\label{sec:flujos-de-trabajo}

\subsection{Introducción}
\label{sec:introduccion-flujos}

Esta sección describirá algunos de los flujos de trabajo más usuales
con Git. Git, al tratarse de un sistema distribuido de control de
versiones, no nos impone ninguno en particular. Sin embargo, en la
práctica se suelen adoptar alguno de los tres enfoques que veremos a
continuación. Estos enfoques han sido tomados de la excelente
presentación <<Getting Git>> de Scott Chacon~\cite{GettingGit}.

En la mayoría de los repositorios Git, existe una rama \rama{master}
que únicamente registra las revisiones estables (publicables) del
sistema, y otra rama \rama{develop} sobre la cual se van situando las
revisiones inestables (\rama{next} en el repositorio de Git). Las
ramas que implementan ciertas funcionalidades salen y se reúnen
después con \rama{develop}, y cuando \rama{develop} está lo bastante
estable, se reúne con \rama{master} (véase la figura~). También pueden
aparecer ramas de mantenimiento de versiones más antiguas, como
\rama{maint} en el repositorio de Git. Se muestra un ejemplo del
aspecto típico de un repositorio Git en funcionamiento en la
figura~\vref{fig:ramas-repo-git}, donde los \orden{git push} se
representan con arcos rojos y los \orden{git pull} con arcos azules.

\begin{figure}
  \centering
  \inputscalew{\textwidth}{ramas-repo-git}
  \caption{Ramificación usual de un repositorio Git}
  \label{fig:ramas-repo-git}
\end{figure}

\subsection{Centralizado}
\label{sec:flujo-centralizado}

El flujo centralizado se corresponde con el utilizado en herramientas
como Subversion o CVS, y utiliza un subconjunto muy pequeño de la
funcionalidad de Git. Se tiene un repositorio <<pelado>> como punto
central de reunión del trabajo de todos los demás desarrolladores, que
clonan ese repositorio (véase la
figura~\vref{fig:flujo-centralizado}).

\begin{figure}
  \centering
  \inputscalew{.6\textwidth}{flujo-centralizado}
  \caption{Flujo centralizado de trabajo}
  \label{fig:flujo-centralizado}
\end{figure}

La forma normal de trabajar es:

\begin{enumerate}
\item Si no se tiene el repositorio ya, habrá que clonarlo, y crear
  una rama local \rama{develop} que vigile la rama remota del mismo nombre:
\begin{lstlisting}
git clone url-a-repositorio
cd repositorio
git checkout -b develop --track origin/develop
\end{lstlisting}

\item Antes de empezar, obtenemos los últimos cambios sobre \rama{develop}:
\begin{lstlisting}
git checkout develop
git pull
\end{lstlisting}

\item Se trabaja a partir de una rama local propia desde la rama
  remota de desarrollo:
\begin{lstlisting}
git checkout -b mi-funcionalidad --track origin/develop
\end{lstlisting}

\item Editamos, depuramos, etc. De vez en cuanto nos interesará
  reunirnos con el trabajo de los demás:

\begin{lstlisting}
git pull --rebase
\end{lstlisting}

  \begin{nota}
    podemos usar aquí la opción \orden{--rebase} ya que esta rama no
    la hemos enviado aún a nadie. En caso contrario, deberíamos hacer
    un \orden{git pull} normal y corriente, que empleará el más seguro
    \orden{git merge}. El uso de esta opción nos permite dejar después
    en el repositorio central un historial más lineal y fácil de
    entender.
  \end{nota}

\item Una vez hayamos terminado nuestro trabajo, cambiaremos a la rama
  local de desarrollo, la actualizaremos y la reuniremos con nuestra
  rama local:

\begin{lstlisting}
git checkout develop
git pull
git merge mi-funcionalidad
\end{lstlisting}

  Si hemos estado reuniendo con frecuencia nuestro trabajo con el de
  los demás, no deberían de producirse conflictos en este paso.

\item Ahora podemos eliminar la antigua rama, si así lo deseamos, y
  empujar los cambios al repositorio:

\begin{lstlisting}
git branch -d mi-funcionalidad
git push
\end{lstlisting}

\item Cuando el director de proyecto (o el responsable de integración)
  vea que la rama de desarrollo tiene la suficiente calidad como para
  constituir la próxima publicación, puede actualizar sus dos ramas
  \rama{master} y \rama{develop}, reunirlas, etiquetar y firmar la
  versión por GnuPG y empujar los cambios:

\begin{lstlisting}
git checkout develop
git pull
git checkout master
git pull
git merge develop
git tag -s v1.0
git push --tags
\end{lstlisting}

\end{enumerate}

\subsection{Distribuido}
\label{sec:flujo-distribuido}

La verdadera utilidad de Git es como un sistema distribuido, en el que
no existe una autoridad central de por sí. En ese aspecto ya no hay
mucho que podamos restringir, y depende ya del tipo de proyecto en que
nos hallemos.

De todas formas, generalmente existe algún repositorio destacado o
<<bendecido>> que la mayoría de los usuarios y desarrolladores toman
como referencia, y que tiene el acceso de escritura restringido a unos
pocos que se ocupan fundamentalmente de integrar el trabajo de los
repositorios públicos de los demás desarrolladores (como en el propio
repositorio de Git). Los desarrolladores actualizan cuando lo ven
necesario sus repositorios públicos a partir de sus privados usando
\orden{git push}. Este modelo con un único nivel de integración se
conoce como el <<modelo del integrador>>, y puede verse un esquema en
la figura~\vref{fig:enc-integracion}. Es interesante ver en los arcos
de \orden{git pull} (azules) del repositorio público del desarrollador
2 al privado del 1 y viceversa cómo los desarrolladores pueden
colaborar entre sí directamente sin necesidad de pasar por el
repositorio bendecido.

\begin{figure}
  \centering
  \inputscalew{.8\textwidth}{flujo-enc-integracion}
  \caption{Flujo del integrador}
  \label{fig:enc-integracion}
\end{figure}

Cuando el trabajo de integración ya no puede ser realizado por una
única persona, surge el <<modelo del dictador y sus tenientes>>, en el
que el trabajo de integración se hace en dos niveles: el dictador
integra el trabajo de sus tenientes, y los tenientes el de los
desarrolladores <<de a pie>>. Es el caso del kernel Linux. Se puede
ver un ejemplo en el que se han reunido en un solo nodo del grafo el
repositorio público y privado de cada desarrollador en la figura~.

\begin{figure}
  \centering
  \inputscalew{.8\textwidth}{flujo-dictador}
  \caption{Flujo del dictador y sus tenientes}
  \label{fig:dictador-tenientes}
\end{figure}

En cuanto a las órdenes necesarias para su uso, no hay mucho que
decir: 

\begin{enumerate}
\item Primero clonaríamos el repositorio bendecido a un repositorio
  público <<pelado>>:

\begin{lstlisting}
git clone --bare url-repositorio-bendecido
\end{lstlisting}

\item Ahora clonaríamos nuestro repositorio público a otro privado,
  esta vez con su directorio de trabajo:

\begin{lstlisting}
git clone url-o-ruta-repositorio-publico ruta-repositorio-privado
\end{lstlisting}

\item Nos introduciríamos en el repositorio e iríamos trabajando de la
  forma usual. Si queremos colaborar con alguien, podemos añadir la
  URL de su repositorio como un \emph{remote} más ejecutando:

\begin{lstlisting}
git remote add nombre-remote url-remote
\end{lstlisting}

  Una vez queda añadido, podemos hacer varias cosas:

  \begin{itemize}
  \item Ver todos los disponibles con \orden{git remote}.
  \item Ver los detalles de uno en particular con \orden{git remote
      show nombre-remoto}.
  \item Retirar uno de la lista con \orden{git remote rm
      nombre-remoto}.
  \item Actualizar las ramas remotas de todos los \emph{remotes} con
    \orden{git remote update}.
  \item Eliminar las ramas remotas que ya no existan en sus
    repositorios con \orden{git remote prune}.
  \end{itemize}

  Por ejemplo, si queremos añadir al repositorio bendecido como otro
  \emph{remote} más en el repositorio privado, podríamos hacer:

\begin{lstlisting}
git remote add central url-del-central
\end{lstlisting}

  Así, podemos actualizar nuestra rama principal desde la principal
  del repositorio bendecido con:

\begin{lstlisting}
git checkout master
git pull central master
\end{lstlisting}

\end{enumerate}

\bibliographystyle{../hispa}
\bibliography{../bibliografia}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
